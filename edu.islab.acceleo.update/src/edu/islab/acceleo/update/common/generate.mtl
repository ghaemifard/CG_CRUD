[comment encoding = UTF-8 /]
[module generate('http://www.update.it.is/v1.0/beta')]
[import edu::islab::acceleo::update::common::updateHelper/]

[template public generateElement(anUpdateSurface : UpdateSurface)]
[comment @main /]
[file (anUpdateSurface.name.concat('.sql'), false, 'utf-8')]
	update [if (anUpdateSurface.tableInstalment.tables->size()>0)]
 	[ anUpdateSurface.tableInstalment.tables->at(1).name/] [ anUpdateSurface.tableInstalment.tables->at(1).alias/]
 [/if]
	[if (anUpdateSurface.tableInstalment.rels->size()>0)]
		[for (v1 : RelationSelect | anUpdateSurface.tableInstalment.rels)]
			[let v2 : InnerjoinRels = v1]
				inner  join  [v2.target.tableOFActField()/] on [v2.source.actFieldName()/] [v2.getSelectRelationType()/] [v2.target.actFieldName()/]
			[/let]
			[let v2 : FullOuterJoinRels = v1]
				full outer  join  [v2.target.tableOFActField()/] on [v2.source.actFieldName()/] [v2.getSelectRelationType()/] [v2.target.actFieldName()/]
			[/let]
			[let v2 : LeftOuterJoinRels = v1]
				left outer  join  [v2.target.tableOFActField()/] on [v2.source.actFieldName()/] [v2.getSelectRelationType()/] [v2.target.actFieldName()/]
			[/let]
			[let v2 : RightOuterJoinRels = v1]
				right outer   join  [v2.target.tableOFActField()/] on [v2.source.actFieldName()/] [v2.getSelectRelationType()/] [v2.target.actFieldName()/]
			[/let]
			
		[/for]
	[/if]
	set [for (v1 : LinkField | anUpdateSurface.lfs) separator (',')]
 	[v1.src.actFieldName()/] = [v1.dst.generateNode()/]
 [/for]
[if (anUpdateSurface.whereInstalment.isThereRoot())]
	where
		[for (v1 : AbstractConditionElement | anUpdateSurface.whereInstalment.parts)]
			[let v2 : RootJunction = v1]
				[v2.generateCondoElement()/]
			[/let]
		[/for]
	[/if]
[if (anUpdateSurface.sortInstalment <> null and anUpdateSurface.sortInstalment.pointers->size() > 0)]
	SORT BY 
	[for (po : FieldSPointer | anUpdateSurface.sortInstalment.pointers) separator (',')] [if (po.field <> null)] [po.field.fieldName()/] [ po.type /] [/if] [/for]
[/if]
[/file]
[file (anUpdateSurface.name.concat('_Func.java'), false, 'utf-8')]
		 
public static List<[anUpdateSurface.associatedClass.toUpperFirst()/]> [anUpdateSurface.name/]( [if (anUpdateSurface.inputInstalment <> null)]
	[for (it : InputDef | anUpdateSurface.inputInstalment.inputs)  separator (',') ] [it.inputName()/] [/for] [/if]){

	DataAccess<[anUpdateSurface.associatedClass.toUpperFirst() /]> da = DataAccess.<[anUpdateSurface.associatedClass.toUpperFirst() /]>getDataAccessInstance();
	return da.resultOperation("[anUpdateSurface.inputInstalment.convertFileToJdbc(anUpdateSurface.name)/]",(stm)-> {
[if (anUpdateSurface.inputInstalment <> null)]
		[anUpdateSurface.inputInstalment.prepareInput(anUpdateSurface.name) /] 
[/if]
		 return true;
	});
}
	 
[/file]
[/template]

[template public getTermRelatianValue(it : ConditionLink) post (trim())] 
[let x : EqualLink = it]=[/let] 
[let x : GreaterThanLink = it]>[/let]
[let x : GreaterEqualThanLink = it]>=[/let]
[let x : LowerThanLink = it]<[/let]
[let x : LowerEqualThanLink = it]<=[/let]
[let x : InLink = it]in[/let]
[let x : LikeLink = it]like[/let]

[/template]
[template public generateDisjuncAnd(dis : Junction) post (trim())]
	    [for (a : JuncRelationship | dis.rels )  separator ('AND')  ]
			( [ generateCondoElement(a.target) /] )
		[/for]
[/template]

[template public generateDisjuncOr(dis : Junction) post (trim())]
	    [for (a : JuncRelationship | dis.rels ) separator ('OR')]
			( [ generateCondoElement(a.target) /] )
		[/for]
[/template]

[template public generateCondoElement(arg : AbstractConditionElement) post (trim())]
	[let e : Junction = arg]
		[if (e.type.isEqualDisType('and'))]
			[ generateDisjuncAnd(e) /]
		[/if]
		[if (e.type.isEqualDisType('or'))]
			[ generateDisjuncOr(e) /]
		[/if] 
	[/let]
	[let e : Term = arg]
		 [e.link.src.generateNode(null)/] [e.link.getTermRelatianValue()/] [ e.link.dst.generateNode(null) /]  
	[/let]
[/template]
[template public getPostfix(it : AbstractNode) post (trim())]
	[let va : Node = it][if (va.column_name <> null and va.column_name.size() > 1)]
 as [va.column_name/] 
[/if] 
[/let]  
[/template]
[template public generateNode(nde: AbstractNode ) post (trim())]
[let n : Field = nde] [if (n.distict)] distinct [/if]   [n.fieldName()/] [/let] 
[let n : Literal = nde] [if (n.ltype = LiteralType::STRING )] "[n.value /]" [else]   [n.value /] [/if][/let]
[let n : NullLiteral = nde]null [if (n.column_name <> null)] [/if] [/let]
[let n : Input = nde][if (n.inputRef <> null)]:[n.inputRef.name /][/if][/let] 
[let n : CallSurfaceQuery = nde] [ n.generateNodep( ) /]  [/let]
[let n : Function = nde] [if ((not nde.isCallQuery()) and n.funcDef <> null)]
[if (n.funcDef.name = '-' or n.funcDef.name = '+' or n.funcDef.name = '*' or n.funcDef.name = '/')]
	( [for (e : Node | n.params) separator (n.funcDef.name)] [generateNode(e)/] [/for] )
[else]
 [n.funcDef.name/]( [for (e : Node | n.params) separator (',')] [generateNode(e)/] [/for] )
[/if]
 [/if] [/let]
[/template]

[template public generateField(f : Field,n : String)]
	[ n /].[f.giveTheColumnName()/]
[/template]
 
[template public giveTheColumnName(aNode: Field) post (trim()) ]
	[if (aNode.column_name <> null and aNode.column_name.size() > 0)]
		 [aNode.column_name/]
	[else]
		 [aNode.name/]
	[/if]
[/template]


[template public inputName(arg : InputDef) post (trim())]
	[let x : InputStringDef = arg] final String  [ x.name /] [/let]
	[let x : InputIntDef = arg ] final int  [ x.name /]	[/let]
	[let x : InputFloatDef = arg] final float  [ x.name /]	[/let]
	[let x : InputDateDef = arg] final Date  [ x.name /] [/let]
	[let x : InputBitsDef = arg] final int  [ x.name /]	[/let]
[/template]